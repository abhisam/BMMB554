<!doctype html>

<html lang="en-us">

<head>
  <title>BMMB 554 | 2018</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Anton Nekrutenko" />
  <meta name="generator" content="Hugo 0.32.3" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://nekrut.github.io/BMMB554/css/styles.css" />
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://nekrut.github.io/BMMB554/">BMMB 554 | 2018</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/galaxyproject"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://github.com/nekrut"><i class="fa fa-github fa-lg" aria-hidden="true"></i></a></li>
           
      </ul>
      
      <p><em>Introduction to data driven life sciences</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://nekrut.github.io/BMMB554/about/">
                <i class="fa-li fa  fa-lg"></i><span>Syllabus</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://nekrut.github.io/BMMB554/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Lectures</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>NGS data: Practicalities</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2018-02-14T00:00:00Z">Feb 14, 2018</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="https://nekrut.github.io/BMMB554/tags/galaxy/">#galaxy</a>
                
                    , 
                    <a href="https://nekrut.github.io/BMMB554/tags/ngs/">#NGS</a>
                
                    , 
                    <a href="https://nekrut.github.io/BMMB554/tags/fastq/">#fastq</a>
                
                    , 
                    <a href="https://nekrut.github.io/BMMB554/tags/sam/">#SAM</a>
                
                    , 
                    <a href="https://nekrut.github.io/BMMB554/tags/bam/">#BAM</a>
                
            </em>
        </li>
        

        <li>25 min read</li>
    </ul>
</aside>
    

    

<p><img src="https://nekrut.github.io/BMMB554/img/topic7_cover.png" alt="" /></p>

<p>In this section we will look at practical aspects of manipulation of next-generation sequencing data. We will start with Fastq format produced by most sequencing machines and will finish with SAM/BAM format representing mapped reads.</p>

<h1 id="set-your-galaxy-to-begin">Set your Galaxy to begin</h1>

<ul>
<li>If you are new Galaxy &#8594; start with the <a href="https://nekrut.github.io/BMMB554/tutorials/g101/">Galaxy 101 tutorual</a></li>
<li>Create a new Galaxy history at <a href="http://usegalaxy.org">http://usegalaxy.org</a> (don&rsquo;t forget to log in).</li>
<li>Import the following four datasets by cutting and pasting these URLs into Galaxy&rsquo;s upload tool (for help see URL upload option in <a href="https://nekrut.github.io/BMMB554/tutorials/upload/">upload tutorial</a>):</li>
</ul>

<pre><code>https://zenodo.org/record/583613/files/sample1-f.fq.gz
https://zenodo.org/record/583613/files/sample1-r.fq.gz
https://zenodo.org/record/583613/files/sample2-f.fq.gz
https://zenodo.org/record/583613/files/sample2-r.fq.gz
</code></pre>

<p>when uploading these dataset set datatype to <code>fastqsanger.gz</code>. The animated image below shows the details of the entire upload process:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/ngs_tutorial_data_upload.gif" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 1</strong>. Uploading data from URL and setting datatype to <code>fastqsanger.gz</code> (this is a loop, so if you missed something it will repeat itself shortly).</small></td>
</tr>
</tbody>
</table>

<p>These are paired end data (datasets with <code>-f</code> is their filename are forward reads and datasets with <code>-r</code> are reverse) representing two independent sampled produced by an Illumina machine.</p>

<p>Upload the datasets. If you&rsquo;ve done everything correctly, you will see Galaxy interface looking like this:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/data_uploaded.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 2</strong>. Data are now uploaded.</small></td>
</tr>
</tbody>
</table>

<h1 id="fastq-manipulation-and-quality-control">Fastq manipulation and quality control</h1>

<h2 id="what-is-fastq">What is Fastq?</h2>

<p><a href="http://en.wikipedia.org/wiki/FASTQ_format">FastQ</a> is not a very well defined format. In the beginning various manufacturers of sequencing instruments were free to interpret fastq as they saw fit, resulting in a multitude of fastq flavors. This variation stemmed primarily from different ways of encoding quality values as described <a href="http://en.wikipedia.org/wiki/FASTQ_format">here</a> (below you will explanation of quality scores and their meaning). Today, <a href="http://www.ncbi.nlm.nih.gov/pubmed/20015970">fastq Sanger</a> version of the format is considered to be the standard form of fastq. Galaxy is using fastq sanger as the only legitimate input for downstream processing tools and provides <a href="http://www.ncbi.nlm.nih.gov/pubmed/20562416">a number of utilities for converting fastq files</a> into this form (see <strong>NGS: QC and manipulation</strong> section of Galaxy tools).</p>

<p>Fastq format looks like this:</p>

<pre><code>
@M02286:19:000000000-AA549:1:1101:12677:1273 1:N:0:23
CCTACGGGTGGCAGCAGTGAGGAATATTGGTCAATGGACGGAAGTCTGAACCAGCCAAGTAGCGTGCAG
+
ABC8C,:@F:CE8,B-,C,-6-9-C,CE9-CC--C-&lt;-C++,,+;CE&lt;,,CD,CEFC,@E9&lt;FCFCF?9
@M02286:19:000000000-AA549:1:1101:15048:1299 1:N:0:23
CCTACGGGTGGCTGCAGTGAGGAATATTGGACAATGGTCGGAAGACTGATCCAGCCATGCCGCGTGCAG
+
ABC@CC77CFCEG;F9&lt;F89&lt;9--C,CE,--C-6C-,CE:++7:,CF&lt;,CEF,CFGGD8FFCFCFEGCF
@M02286:19:000000000-AA549:1:1101:11116:1322 1:N:0:23
CCTACGGGAGGCAGCAGTAGGGAATCTTCGGCAATGGACGGAAGTCTGACCGAGCAACGCCGCGTGAGT
+
AAC&lt;CCF+@@&gt;CC,C9,F9C9@9-CFFFE@7@:+CC8-C@:7,@EFE,6CF:+8F7EFEEF@EGGGEEE

</code></pre>

<p>Each sequencing read is represented by four lines:</p>

<ol>
<li><code>@</code> followed by read ID and optional information about sequencing run</li>
<li>sequenced bases</li>
<li><code>+</code> (optionally followed by the read ID and some additional info)</li>
<li>quality scores for each base of the sequence encoded as <a href="https://en.wikipedia.org/wiki/ASCII">ASCII symbols</a></li>
</ol>

<h2 id="paired-end-data">Paired end data</h2>

<p>It is common to prepare pair-end and mate-pair sequencing libraries. This is highly beneficial for a number of applications discussed in subsequent topics. This is because in addition to sequence data we know that forward and reverse reads are physically linked within the sequenced molecule. For now let&rsquo;s just briefly discuss what these are and how they manifest themselves in fastq form.</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/pe_mp.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 3. Paired-end and mate-pair reads</strong>. In paired end sequencing (left) the actual ends of rather short DNA molecules (less than 1kb) are determined, while for mate pair sequencing (right) the ends of long molecules are joined and prepared in special sequencing libraries. In these mate pair protocols, the ends of long, size-selected molecules are connected with an internal adapter sequence (i.e. linker, yellow) in a circularization reaction. The circular molecule is then processed using restriction enzymes or fragmentation. Fragments are enriched for the linker and outer library adapters are added around the two combined molecule ends. The internal adapter can then be used as a second priming site for an additional sequencing reaction in the same orientation or sequencing can be performed from the second adapter, from the reverse strand. (From Ph.D. dissertation by <a href="https://core.ac.uk/download/pdf/35186947.pdf">Martin Kircher</a>)</small></td>
</tr>
</tbody>
</table>

<p>Thus in both cases (paired-end and mate-pair) a single physical piece of DNA (or RNA in the case of RNA-seq) is sequenced from two ends and so generates two reads. These can be represented as separate files (two fastq files with first and second reads) or a single file were reads for each end are interleaved. Here are examples:</p>

<h3 id="two-single-files">Two single files</h3>

<p><strong>File 1</strong></p>

<pre><code> @M02286:19:000000000-AA549:1:1101:12677:1273 1:N:0:23
 CCTACGGGTGGCAGCAGTGAGGAATATTGGTCAATGGACGGAAGTCT
 +
 ABC8C,:@F:CE8,B-,C,-6-9-C,CE9-CC--C-&lt;-C++,,+;CE
 @M02286:19:000000000-AA549:1:1101:15048:1299 1:N:0:23
 CCTACGGGTGGCTGCAGTGAGGAATATTGGACAATGGTCGGAAGACT
 +
 ABC@CC77CFCEG;F9&lt;F89&lt;9--C,CE,--C-6C-,CE:++7:,CF
</code></pre>

<p><strong>File 2</strong></p>

<pre><code>@M02286:19:000000000-AA549:1:1101:12677:1273 2:N:0:23
CACTACCCGTGTATCTAATCCTGTTTGATACCCGCACCTTCGAGCTTA
+
--8A,CCE+,,;,&lt;CC,,&lt;CE@,CFD,,C,CFF+@+@CCEF,,,B+C,
@M02286:19:000000000-AA549:1:1101:15048:1299 2:N:0:23
CACTACCGGGGTATCTAATCCTGTTCGCTCCCCACGCTTTCGTCCATC
+
-6AC,EE@::CF7CFF&lt;&lt;FFGGDFFF,@FGGGG?F7FEGGGDEFF&gt;FF
</code></pre>

<div class="alert alert-info" role="alert">

**Note** that read IDs are **identical** in two files and they are listed in **the same** order. In some cases read IDs in the first and second file may be appended with `/1` and `/2` tags, respectively. 

</div>

<h3 id="interleaved-file">Interleaved file</h3>

<pre><code>@1/1
AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
+
EGGEGGGDFGEEEAEECGDEGGFEEGEFGBEEDDECFEFDD@CDD&lt;ED
@1/2
CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
+
GHHHDFDFGFGEGFBGEGGEGEGGGHGFGHFHFHHHHHHHEF?EFEFF
@2/1
AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
+
HHHHHHEGFHEEFEEHEEHHGGEGGGGEFGFGGGGHHHHFBEEEEEFG
@2/2
CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
+
HHHHHHHHHHHHHGHHHHHHGHHHHHHHHHHHFHHHFHHHHHHHHHHH
</code></pre>

<p>Here the first and the second reads are identified with <code>/1</code> and <code>/2</code> tags (but even without these tags we know that odd reads are in <em>forward</em> orientation and even are in <em>reverse</em>).</p>

<div class="alert alert-warning" role="alert">
Fastq format is not strictly defined and its variations will always cause headache for you. See [this page](https://www.ncbi.nlm.nih.gov/books/NBK242622/) for more information.
</div>

<h2 id="what-are-base-qualities">What are base qualities?</h2>

<p>As we&rsquo;ve seen above, fastq datasets contain two types of information:</p>

<ul>
<li><em>sequence of the read</em></li>
<li><em>base qualities</em> for each nucleotide in the read.</li>
</ul>

<p>The base qualities allow us to judge how trustworthy each base in a sequencing read is. The following excerpt from an excellent <a href="http://chagall.med.cornell.edu/RNASEQcourse/Intro2RNAseq.pdf">tutorial</a> by Friederike D&uuml;ndar, Luce Skrabanek, Paul Zumbo explains what base qualities are:</p>

<blockquote>
<p>Illumina sequencing is based on identifying the individual nucleotides by the fluorescence signal emitted upon their incorporation into the growing sequencing read. Once the fluorescence intensities are extracted and translated into the four letter code. The deduction of nucleotide sequences from the images acquired during sequencing is commonly referred to as base calling. Due to the imperfect nature of the sequencing process and limitations of the optical instruments, base calling will always have inherent uncertainty. This is the reason why FASTQ files store the DNA sequence of each read together with a position-specific quality score that represents the error probability, i.e., how likely it is that an individual base call may be incorrect. The score is called <a href="http://www.phrap.com/phred/">Phred score</a>, $Q$, which is proportional to the probability $p$ that a base call is incorrect, where $Q = −10lg(p)$. For example, a Phred score of 10 corresponds to one error in every ten base calls ($Q = −10lg(0.1)$), or 90% accuracy; a Phred score of 20 corresponds to one error in every 100 base calls, or 99% accuracy. A higher Phred score thus reflects higher confidence in the reported base. To assign each base a unique score identifier (instead of numbers of varying character length), Phred scores are typically represented as ASCII characters. At <a href="http://ascii-code.com/">http://ascii-code.com/</a> you can see which characters are assigned to what number. For raw reads, the range of scores will depend on the sequencing technology and the base caller used (Illumina, for example, used a tool called Bustard, or, more recently, RTA). Unfortunately, Illumina has been anything but consistent in how they calculated and ASCII-encoded the Phred score (see below)! In addition, Illumina now allows Phred scores for base calls with as high as 45, while 41 used to be the maximum score until the HiSeq X. This may cause issues with downstream applications that expect an upper limit of 41.</p>

<p><img src="https://nekrut.github.io/BMMB554/img/illumina_qs.png" alt="" /></p>
</blockquote>

<p>Base call qualities are represented using the <a href="https://en.wikipedia.org/wiki/Phred_quality_score">Phred score scale</a>. Different Illumina (formerly Solexa) versions used different scores and ASCII offsets. Starting with Illumina format 1.8, the score now represents the standard
Sanger/Phred format that is also used by other sequencing platforms and the sequencing archives.</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/fastq_qs.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 4.</strong> The ASCII interpretation and ranges of the different Phred score notations used by Illumina and the original Sanger interpretation. Although the Sanger format allows a theoretical score of 93, raw sequencing reads typically do not exceed a Phred score of 60. In fact, most Illumina-based sequencing will result in maximum scores of 41 to 45 (image from <a href="https://en.wikipedia.org/wiki FASTQ_format">Wikipedia</a>).</small></td>
</tr>
</tbody>
</table>

<h2 id="assessing-data-quality">Assessing data quality</h2>

<p>One of the first steps in the analysis of NGS data is seeing how good the data actually is. <a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">FastQC</a> is a fantastic tool allowing you to evaluate the quality of fastq datasets (and deciding whether to blame or not to blame whoever has done sequencing for you).</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><img src="https://nekrut.github.io/BMMB554/img/good_fq.png" alt="" /></td>
<td align="left"><img src="https://nekrut.github.io/BMMB554/img/bad_fq.png" alt="" /></td>
</tr>

<tr>
<td align="left"><small><strong>Figure 5. Left:</strong> Excellent quality.</small></td>
<td align="left"><small><strong>Right:</strong> Hmmmm&hellip;.Ok.</small></td>
</tr>
</tbody>
</table>

<p>Here you can see FastQC base quality reports (the tools gives you many other types of data) for two datasets: <strong>A</strong> and <strong>B</strong>. The <strong>A</strong> dataset has long reads (250 bp) and very good quality profile with no qualities dropping below <a href="http://www.phrap.com/phred/">phred score</a> of 30. The <strong>B</strong> dataset is significantly worse with ends of the reads dipping below phred score of 20. The <strong>B</strong> reads may need to be trimmed for further processing.</p>

<p>It may be challenging to use <code>fastQC</code> when you have a lot of datasets. For example, in our case there are four datasets. <code>FastQC</code> needs to be run on each dataset individually and then one needs to look at each <code>fastQC</code> report individually. This may not be a big problem for four datasets, but it will become an issue if you have 100s or 1,000s of datasets. <a href="https://github.com/ewels">Phil Ewels</a> has developed a tool called <a href="http://multiqc.info/"><code>MultiQC</code></a> that allows to summarize multiple QC reports at once. To run <code>MultiQC</code> you need to run <code>fastQC</code> on individual datasets and then feed fastQC outputs to <code>MultiQC</code> (note that <code>MultiQC</code> is not limited to processing FastQC reports but accepts outputs of many other tools). Galaxy makes this easy as shown in the following video:</p>

<iframe src="https://player.vimeo.com/video/123453134?byline=0&portrait=0" width="640" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p>In this video we run <code>FastQC</code> on the four datasets and then summarized these data with <code>MultiQC</code>. The following figure shows one of the graphs produced by <code>MultiQC</code>:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/multiqc.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 6.</strong> A <code>MultiQC</code> report showing quality score distribution for the four sequences using in this tutorial. Here <code>sample1-f</code> has highest quality: its quality scores never dip below phred score of 25. The other datasets are slightly worse, but all are generally acceptable.</small></td>
</tr>
</tbody>
</table>

<h2 id="trimming-reads">Trimming reads</h2>

<p>One of the conclusions from our QC analyses (Fig. 6) is that the quality is acceptable but drops towards the end of the reads (this is typical for Illumina which uses reverse terminators bases with cleave-able color labels. Because the process of cleaving terminators and color labels is not 100% efficient noise accumulates as run progresses and so bases at the ends of reads tend to have lower quality). There is a number of steps we can take to mitigate the effect of low quality bases. One is dynamically trim the reads:</p>

<ul>
<li>slide a window across reads</li>
<li>at every step of the process calculate average quality of bases within the given window</li>
<li>if quality drops below certain set threshold &#8594; stop and trim the read of the read from this point until the end</li>
<li>output the beginning of the read</li>
</ul>

<p>One of the tools that performs this procedure is <a href="http://www.usadellab.org/cms/?page=trimmomatic">Trimmomatic</a> developed by Usadel <a href="http://www.usadellab.org/cms/index.php?page=staff">lab</a>. Let&rsquo;s use <strong>NGS: QC and manipulation &#8594; Trimmomatic</strong> to trim out four datasets:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/trimmomatic.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 7.</strong> Trimming our datasets with <a href="http://www.usadellab.org/cms/?page=trimmomatic">Trimmomatic</a>. Here reads will be trimmed if the base quality averaged across four bases drops below 25.</small></td>
</tr>
</tbody>
</table>

<p>To see the effect of trimming on the reads let&rsquo;s take Trimmomatic output, run it through FastQC (<strong>NGS: QC and manipulation &#8594; FastQC</strong>and summarize with MultiQC (<strong>NGS: QC and manipulation &#8594; multiQC</strong>). Below is the quality score distribution graph (the same graph shown in Fig. 6):</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/multiqc2.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 8</strong>. Quality score distribution for trimmed datasets. Compare this image with Fig. 6. You can see that sequences are shorted but quality is significantly higher.</small></td>
</tr>
</tbody>
</table>

<p>We will now use trimmed reads as the input to downstream analyses.</p>

<h2 id="try-it-yourself">Try it yourself</h2>

<p>QC, trim, and QC again datasets you have uploaded before to produce a final set of sequences we will be using downstream.</p>

<h1 id="mapping-your-data">Mapping your data</h1>

<p>Mapping of NGS reads against reference sequences is one of the key steps of the analysis. Now it is time to see how this is done in practice. Below is a list of key publications highlighting mainstream mapping tools:</p>

<ul>
<li>2009 Bowtie 1 - <a href="http://genomebiology.com/content/10/3/R25">Langmead et al.</a></li>
<li>2012 Bowtie 2 - <a href="http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.htm">Langmead and Salzberg</a></li>
<li>2009 BWA - <a href="http://bioinformatics.oxfordjournals.org/content/25/14/1754.long">Li and Durbin</a></li>
<li>2010 BWA - <a href="http://bioinformatics.oxfordjournals.org/content/26/5/589">Li and Durbin</a></li>
<li>2013 BWA-MEM - <a href="http://arxiv.org/abs/1303.3997">Li</a></li>
</ul>

<h2 id="mapping-against-a-pre-computed-genome-index">Mapping against a pre-computed genome index</h2>

<p>Mappers usually compare reads against a reference sequence that has been transformed into a highly accessible data structure called genome index. Such indexes should be generated before mapping begins. Galaxy instances typically store indexes for a number of publicly available genome builds.</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/cached_genome.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 9</strong>. Mapping against a pre-computed index in Galaxy.</small></td>
</tr>
</tbody>
</table>

<p>For example, the image above shows indexes for <code>hg38</code> version of the human genome. You can see that there are actually three choices: (1) <code>hg38</code>, (2) <code>hg38 canonical</code> and (3) <code>hg38 canonical female</code>. The <code>hg38</code> contains all chromosomes as well as all unplaced contigs. The <code>hg38 canonical</code> does not contain unplaced sequences and only consists of chromosomes 1 through 22, X, Y, and mitochondria. The
<code>hg38 canonical female</code> contains everything from the canonical set with the exception of chromosome Y.</p>

<p>The following video show mapping using BWA-MEM:</p>

<iframe src="https://player.vimeo.com/video/123102338?byline=0&portrait=0" width="640" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<h3 id="try-it-yourself-1">Try it yourself</h3>

<p>Map datasets uploaded before using BWA against <code>hg38</code> version of the human genome.</p>

<h2 id="what-if-pre-computed-index-does-not-exist">What if pre-computed index does not exist?</h2>

<p>If Galaxy does not have a genome you need to map against, you can upload your genome sequence as a FASTA file and use it in the mapper directly as shown below (<strong>Load reference genome</strong> is set to <code>History</code>).</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/uploaded_genome.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 10</strong>. Mapping against a custom index in Galaxy </small></td>
</tr>
</tbody>
</table>

<p>In this case Galaxy will first create an index from this dataset and then run mapping analysis against it. The following video shows how this works in practice:</p>

<iframe src="https://player.vimeo.com/video/123108417?byline=0&portrait=0" width="640" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<h1 id="sam-bam-datasets">SAM/BAM datasets</h1>

<p>The <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAM/BAM</a> format is an accepted standard for storing aligned reads (it can also store unaligned reads and some mappers such as BWA are accepting unaligned BAM as input). The binary form of the format (BAM) is compact and can be rapidly searched (if indexed). In Galaxy BAM datasets are always indexed (accompanies by a .bai file) and sorted in coordinate order. In the following discussion I once again rely on <a href="http://chagall.med.cornell.edu/RNASEQcourse/Intro2RNAseq.pdf">tutorial</a> by Friederike D&uuml;ndar, Luce Skrabanek, and Paul Zumbo.</p>

<p>The Sequence Alignment/Map (SAM) format is a generic nucleotide alignment format that describes the alignment of sequencing reads (or query sequences) to a reference. The human readable, TAB-delimited SAM files can be compressed into the Binary Alignment/Map format. These BAM files are bigger than simply gzipped SAM files, because they have been optimized for fast random access rather than size reduction. Position-sorted BAM files can be indexed so that all reads aligning to a locus can be efficiently retrieved without loading the entire file into memory.</p>

<p>As shown below, SAM files typically contain a header section and an alignment section where each row represents a single read alignment. The following sections will explain the SAM format in a bit more detail. For the most comprehensive and updated information go to <a href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</a>.</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/bam_structure.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 11. Schematic representation of a SAM file</strong>. Each line of the optional header section starts with “@”, followed by the appropriate abbreviation (e.g., SQ for sequence dictionary which lists all chromosomes names (SN) and their lengths (LN)). The vast majority of lines within a SAM file typically correspond to read alignments where each read is described by the 11 mandatory entries (black font) and a variable number of optional fields (grey font; from <a href="http://chagall.med.cornell.edu/RNASEQcourse/Intro2RNAseq.pdf">tutorial</a> by Friederike D&uuml;ndar, Luce Skrabanek, and Paul Zumbo).</small></td>
</tr>
</tbody>
</table>

<h2 id="sam-header">SAM Header</h2>

<p>The header section includes information about how the alignment was generated and stored. All lines in the header section are tab-delimited and begin with the “@” character, followed by tag:value pairs, where tag is a two-letter string that defines the content and the format of value. For example, the “@SQ” line in the header section contains the information about the names and lengths of the *reference sequences to which the reads were aligned. For a hypothetical organism with three chromosomes of length 1,000 bp, the SAM header should contain the following three lines:</p>

<pre><code>@SQ SN:chr1 LN:1000
@SQ SN:chr2 LN:1000
@SQ SN:chr3 LN:1000
</code></pre>

<h2 id="sam-alignment-section">SAM alignment section</h2>

<p>The optional header section is followed by the alignment section where each line corresponds to one sequenced read. For each read, there are 11 mandatory fields that always appear in the same order:</p>

<pre><code>&lt;QNAME&gt; &lt;FLAG&gt; &lt;RNAME&gt; &lt;POS&gt; &lt;MAPQ&gt; &lt;CIGAR&gt; &lt;MRNM&gt; &lt;MPOS&gt; &lt;ISIZE&gt; &lt;SEQ&gt; &lt;QUAL&gt;
</code></pre>

<p>If the corresponding information is unavailable or irrelevant, field values can be ‘0’ or ‘*’ (depending on the field, see below), but they cannot be missing! After the 11 mandatory fields, a variable number of optional fields can be present. Here’s an example of one single line of a real-life SAM file (you may need to scroll sideways):</p>

<pre><code>ERR458493 .552967 16 chrI 140 255 12 M61232N37M2S * 0 0 CCACTCGTTCACCAGGGCCGGCGGGCTGATCACTTTATCGTGCATCTTGGC BB?HHJJIGHHJIGIIJJIJGIJIJJIIIGHBJJJJJJHHHHFFDDDA1+B NH:i:1 HI:i:1 AS:i:41 nM:i:2
</code></pre>

<p>The following table explains the format and content of each field. The <code>FLAG</code>, <code>CIGAR</code>, and the optional fields (marked in blue) are explained in more detail below. The number of optional fields can vary widely between different SAM files and even between reads within in the same file. The field types marked in blue are explained in more detail in the main text below.</p>

<p><img src="https://nekrut.github.io/BMMB554/img/sam_fields.png" alt="" /></p>

<h3 id="flag-field"><code>FLAG</code> field</h3>

<p>The FLAG field encodes various pieces of information about the individual read, which is particularly important for PE reads. It contains an integer that is generated from a sequence of Boolean bits (0, 1). This way, answers to multiple binary (Yes/No) questions can be compactly stored as a series of bits, where each of the single bits can be addressed and assigned separately.</p>

<p>The following table gives an overview of the different properties that can be encoded in the FLAG field. The developers of the SAM format and samtools tend to use the hexadecimal encoding as a means to refer to the different bits in their documentation. The value of the FLAG field in a given SAM file, however, will always be the decimal representation of the sum of the underlying binary values (as shown in Table below, row 2).</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/sam_flag.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 12</strong>. The <code>FLAG</code> field of SAM files stores information about the respective read alignment in one single decimal number. The decimal number is the sum of all the answers to the Yes/No questions associated with each binary bit. The hexadecimal representation is used to refer to the individual bits (questions). A bit is set if the corresponding state is true. For example, if a read is paired, <code>0x1</code> will be set, returning the decimal value of 1. Therefore, all <code>FLAG</code> values associated with paired reads must be uneven decimal numbers. Conversely, if the <code>0x1</code> bit is unset (= read is not paired), no assumptions can be made about <code>0x2</code>, <code>0x8</code>, <code>0x20</code>, <code>0x40</code> and <code>0x80</code> because they refer to paired reads (from <a href="http://chagall.med.cornell.edu/RNASEQcourse/Intro2RNAseq.pdf">tutorial</a> by Friederike D&uuml;ndar, Luce Skrabanek, and Paul Zumbo).</small></td>
</tr>
</tbody>
</table>

<p>In a run with single reads, the flags you most commonly see are:</p>

<ul>
<li>0: This read has been mapped to the forward strand. (None of the bit-wise flags have been set.)</li>
<li>4: The read is unmapped (<code>0x4</code> is set).</li>
<li>16: The read is mapped to the reverse strand (<code>0x10</code> is set)</li>
</ul>

<p>(<code>0x100</code>, <code>0x200</code> and <code>0x400</code> are not used by most aligners/mappers, but could, in principle be set for single reads.) Some common <code>FLAG</code> values that you may see in a PE experiment include:</p>

<table>
<thead>
<tr>
<th>FLAG value</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>69</strong> (= 1 + 4 + 64)</td>
<td>The read is paired, is the first read in the pair, and is unmapped.</td>
</tr>

<tr>
<td><strong>77</strong> (= 1 + 4 + 8 + 64)</td>
<td>The read is paired, is the first read in the pair, both are unmapped.</td>
</tr>

<tr>
<td><strong>83</strong> (= 1 + 2 + 16 + 64)</td>
<td>The read is paired, mapped in a proper pair, is the first read in the pair, and it is mapped to the reverse strand.</td>
</tr>

<tr>
<td><strong>99</strong> (= 1 + 2 + 32 + 64)</td>
<td>The read is paired, mapped in a proper pair, is the first read in the pair, and its mate is mapped to the reverse strand.</td>
</tr>

<tr>
<td><strong>133</strong> (= 1 + 4 + 128)</td>
<td>The read is paired, is the second read in the pair, and it is unmapped.</td>
</tr>

<tr>
<td><strong>137</strong> (= 1 + 8 + 128)</td>
<td>The read is paired, is the second read in the pair, and it is mapped while its mate is not.</td>
</tr>

<tr>
<td><strong>141</strong> (= 1 + 4 + 8 + 128)</td>
<td>The read is paired, is the second read in the pair, but both are unmapped.</td>
</tr>

<tr>
<td><strong>147</strong> (= 1 + 2 + 16 + 128)</td>
<td>The read is paired, mapped in a proper pair, is the second read in the pair, and mapped to the reverse strand.</td>
</tr>

<tr>
<td><strong>163</strong> (= 1 + 2 + 32 + 128)</td>
<td>The read is paired, mapped in a proper pair, is the second read in the pair, and its mate is mapped to the reverse strand.</td>
</tr>
</tbody>
</table>

<p>A useful website for quickly translating the FLAG integers into plain English explanations like the ones shown above is: <a href="https://broadinstitute.github.io/picard/explain-flags.html">https://broadinstitute.github.io/picard/explain-flags.html</a></p>

<h3 id="cigar-string"><code>CIGAR</code> string</h3>

<p><code>CIGAR</code> stands for <em>Concise Idiosyncratic Gapped Alignment Report</em>. This sixth field of a SAM file
contains a so-called CIGAR string indicating which operations were necessary to map the read to the reference sequence at that particular locus.</p>

<p>The following operations are defined in CIGAR format (also see figure below):</p>

<ul>
<li><strong>M</strong> - Alignment (can be a sequence match or mismatch!)</li>
<li><strong>I</strong> - Insertion in the read compared to the reference</li>
<li><strong>D</strong> - Deletion in the read compared to the reference</li>
<li><strong>N</strong> - Skipped region from the reference. For mRNA-to-genome alignments, an N operation represents an intron. For other types of alignments, the interpretation of N is not defined.</li>
<li><strong>S</strong> - Soft clipping (clipped sequences are present in read); S may only have H operations between them and the ends of the string</li>
<li><strong>H</strong> - Hard clipping (clipped sequences are NOT present in the alignment record); can only be present as the first and/or last operation</li>
<li><strong>P</strong> - Padding (silent deletion from padded reference)</li>
<li><strong>=</strong> - Sequence match (not widely used)</li>
<li><strong>X</strong> - Sequence mismatch (not widely used)</li>
</ul>

<p>The sum of lengths of the <strong>M</strong>, <strong>I</strong>, <strong>S</strong>, <strong>=</strong>, <strong>X</strong> operations must equal the length of the read. Here are some examples:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/cigar.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 13</strong>. Examples of CIGAR strings (from <a href="http://chagall.med.cornell.edu/RNASEQcourse/Intro2RNAseq.pdf">tutorial</a> by Friederike D&uuml;ndar, Luce Skrabanek, and Paul Zumbo).</small></td>
</tr>
</tbody>
</table>

<h3 id="optional-fields">Optional fields</h3>

<p>Following the eleven mandatory SAM file fields, the optional fields are presented as key-value
pairs in the format of <code>&lt;TAG&gt;:&lt;TYPE&gt;:&lt;VALUE&gt;</code>, where <code>TYPE</code> is one of:</p>

<ul>
<li><code>A</code> - Character</li>
<li><code>i</code> - Integer</li>
<li><code>f</code> - Float number</li>
<li><code>Z</code> - String</li>
<li><code>H</code> - Hex string</li>
</ul>

<p>The information stored in these optional fields will vary widely depending on the mapper and new tags can be added freely. In addition, reads within the same SAM file may have different numbers of optional fields, depending on the program that generated the SAM file. Commonly used optional tags include:</p>

<ul>
<li><code>AS:i</code> - Alignment score</li>
<li><code>BC:Z</code> - Barcode sequence</li>
<li><code>HI:i</code> - Match is i-th hit to the read</li>
<li><code>NH:i</code> - Number of reported alignments for the query sequence</li>
<li><code>NM:i</code> - Edit distance of the query to the reference</li>
<li><code>MD:Z</code> - String that contains the exact positions of mismatches (should complement the CIGAR string)</li>
<li><code>RG:Z</code> - Read group (should match the entry after ID if @RG is present in the header.</li>
</ul>

<p>Thus, for example, we can use the NM:i:0 tag to select only those reads which map perfectly to the reference(i.e., have no mismatches). While the optional fields listed above are fairly standardized, tags that begin with <code>X</code>, <code>Y</code>, and <code>Z</code> are reserved for particularly free usage and will never be part of the official SAM file format specifications. <code>XS</code>, for example, is used by TopHat (an RNA-seq analysis tool we will discuss later) to encode the strand information (e.g., <code>XS:A:+</code>) while Bowtie2 and BWA use <code>XS:i:</code> for reads with multiple alignments to store the alignment score for the next-best-scoring alignment (e.g., <code>XS:i:30</code>).</p>

<h2 id="read-groups">Read Groups</h2>

<p>One of the key features of SAM/BAM format is the ability to label individual reads with readgroup tags. This allows pooling results of multiple experiments into a single BAM dataset. This significantly simplifies downstream logistics: instead of dealing with multiple datasets one can handle just one. Many downstream analysis tools such as variant callers are designed to recognize readgroup data and output results on per-readgroup basis.</p>

<p>One of the best descriptions of BAM readgroups is on <a href="http://gatkforums.broadinstitute.org/discussion/1317/collected-faqs-about-bam-files">GATK support site</a>. We have gratefully stolen two tables describing the most important readgroup tags - <code>ID</code>, <code>SM</code>, <code>LB</code>, and <code>PL</code> - from GATK forum and provide them here:</p>

<p><img src="https://nekrut.github.io/BMMB554/img/rg.png" alt="" /></p>

<p>GATK forum also provides the following example:</p>

<p><img src="https://nekrut.github.io/BMMB554/img/rg_example.png" alt="" /></p>

<p>To see an example of read group manipulation in Galaxy see the following video. In this video we use two BAM datasets as an example. We add readgroups and shown how it changes the underling BAM (SAM) data:</p>

<iframe src="https://player.vimeo.com/video/219683864?byline=0&portrait=0" width="640" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<h2 id="effects-of-pcr-duplicates">Effects of PCR duplicates</h2>

<p>Preparation of sequencing libraries (at least at the time of writing) for technologies such as Illumina involves PCR amplification. It is required to generate sufficient number of sequencing templates so that a reliable detection can be performed by base callers. Yet PCR has it&rsquo;s biases, which are especially profound in cases of multitemplate PCR used for construction of sequencing libraries (Kanagawa et al. <a href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&amp;db=PubMed&amp;dopt=Abstract&amp;list_uids=16233530">2003</a>).</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/pcr-duplicates.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 14</strong>. Analyzing molecules aligning with the same outer coordinates, a mapping quality of at least 30 and a length of at least 30nt, resulted in an average coverage of 12.9 per PCR duplicate and an empirical coverage distribution similar to an exponential/power law distribution (left upper panel). This indicates that many molecules are only observed for deeper sequencing while other molecules are available at higher frequencies. Analyzing length (left middle panel) and GC content (left lower panel) patterns as well as the combination (right panel) shows higher PCR duplicate counts for a GC content between 30% to 70% as well as for shorter molecules compared to longer molecules. This effect may be due to an amplification bias from the polymerase or the cluster generation process necessary for Illumina sequencing. From Ph.D. dissertation of <a href="http://www.qucosa.de/fileadmin/data/qucosa/documents/7110/pflichtexemplar_final.pdf">Martin Kircher</a>).</small></td>
</tr>
</tbody>
</table>

<p>Duplicates can be identified based on their outer alignment coordinates or using sequence-based clustering. One of the common ways for identification of duplicate reads is the <code>MarkDuplicates</code> utility from <a href="https://broadinstitute.github.io/picard/command-line-overview.html">Picard</a> package. It is designed to identify both PCR and optical duplicates:</p>

<div class="well well-lg">

Duplicates are identified as read pairs having identical 5' positions (coordinate and strand) for both reads in a mate pair (and optionally, matching unique molecular identifier reads; see BARCODE_TAG option). Optical, or more broadly Sequencing, duplicates are duplicates that appear clustered together spatially during sequencing and can arise from optical/imagine-processing artifacts or from bio-chemical processes during clonal amplification and sequencing; they are identified using the READ_NAME_REGEX and the OPTICAL_DUPLICATE_PIXEL_DISTANCE options. The tool's main output is a new SAM or BAM file in which duplicates have been identified in the SAM flags field, or optionally removed (see REMOVE_DUPLICATE and REMOVE_SEQUENCING_DUPLICATES), and optionally marked with a duplicate type in the 'DT' optional attribute. In addition, it also outputs a metrics file containing the numbers of READ_PAIRS_EXAMINED, UNMAPPED_READS, UNPAIRED_READS, UNPAIRED_READ DUPLICATES, READ_PAIR_DUPLICATES, and READ_PAIR_OPTICAL_DUPLICATES. Usage example: java -jar picard.jar MarkDuplicates I=input.bam \ O=marked_duplicates.bam M=marked_dup_metrics.txt.`

</div>

<h2 id="sampling-coincidence-duplicates">Sampling coincidence duplicates</h2>

<p>However, one has to be careful when removing duplicates in cases when the sequencing targets are small (e.g., sequencing of bacterial, viral, or organellar genomes as well as amplicons). This is because when sequencing target is small reads will have the same coordinates by chance and not because of PCR amplification issues. The figure below illustrates the fine balance between estimates allele frequency, coverage, and variation in insert size:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/sampling-bias.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 15</strong>. The Variant Allele Frequency (VAF) bias determined by coverage and insert size variance. Reads are paired-end and read length is 76. The insert size distribution is modeled as a Gaussian distribution with mean at 200 and standard deviation shown on the x-axis. The true VAF is 0.05. The darkness at each position indicates the magnitude of the bias in the VAF. (From Zhou et al. <a href="http://bioinformatics.oxfordjournals.org/content/30/8/1073">2013</a>).</small></td>
</tr>
</tbody>
</table>

<h1 id="putting-it-all-together">Putting it all together</h1>

<p>In Galaxy we support four major toolsets for processing of SAM/BAM datasets:</p>

<ul>
<li><a href="https://deeptools.github.io/">DeepTools</a> - a suite of user-friendly tools for the visualization, quality control and normalization of data from deep-sequencing DNA sequencing experiments.</li>
<li><a href="http://www.htslib.org/">SAMtools</a> - various utilities for manipulating alignments in the SAM/BAM format, including sorting, merging, indexing and generating alignments in a per-position format.</li>
<li><a href="https://github.com/pezmaster31/bamtools/wiki/Tutorial_Toolkit_BamTools-1.0.pdf">BAMtools</a> - a toolkit for reading, writing, and manipulating BAM (genome alignment) files.</li>
<li><a href="http://broadinstitute.github.io/picard/">Picard</a> - a set of Java tools for manipulating high-throughput sequencing data (HTS) data and formats.</li>
</ul>

<p>The following two videos highlight major steps of fastq-to-BAM analysis trajectory.</p>

<h2 id="organizing-and-qc-ing-multiple-datasets">Organizing and QC&rsquo;ing multiple datasets</h2>

<p>In a typical analysis scenario a user usually processes multiple datasets. To make the two following videos representative of real-live analyses we use a set of four samples, each consisting of two forward and reverse sets of reads for a total of eight fastq datasets. The first video describes upload, QC, and preparation of these datasets for the subsequent analysis. The figure below outlines steps highlighted in the video:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/movie1.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 16</strong>. The analysis shown in this figure and the following video begins with uploading of 8 datasets into history. These datasets are first combined into a flat collection - a single entity containing eight fastq datasets. This collection is then analyzed with <code>fastQC</code> tool. This analyses produces another collection containing 8 <code>fastQC</code> outputs. Because it is inconvenient to look at individual <code>fastQC</code> reports, we feed the entire collection to <code>multiQC</code> tool, which produces a single summary outputs aggregating data from 8 <code>fastQC</code> reports.  At this point we are happy with the quality of the data and ready to move on with the subsequent analysis. To do this we organize our datasets into a different type of collection - a paired collection. You can see that the paired collection is &ldquo;deeper&rdquo; that a flat collection: it contains samples and for each sample is lists corresponding sets of forward and reverse reads (shown and red and blue boxes with &ldquo;F&rdquo; and &ldquo;R&rdquo;). To learn more about collections see <a href="https://nekrut.github.io/BMMB554/tutorials/collections">this tutorial</a>.</small></td>
</tr>
</tbody>
</table>

<p>{<iframe src="https://player.vimeo.com/video/219916942?byline=0&portrait=0" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></p>

<p><br></p>

<p>After QC&rsquo;ing we move on to map the reads, process the resulting BAM datasets, and visualize coverage in a genome browser. The following figure and video detail these steps:</p>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="https://nekrut.github.io/BMMB554/img/movie2.png" alt="" /></td>
</tr>

<tr>
<td><small><strong>Figure 17</strong>. In this analysis (see video below) we begin with a paired collection of fastq datasets. Mapping this collection to human genome with <code>bwa mem</code> produces a flat collection of BAM datasets. (<strong>EXTREMELY IMPORTANT</strong>: when mapping with <code>bwa mem</code> we set readgroups (at time marker 00:40 in the video). This allows us to merge individual BAM datasets into one at the end of this analysis.) Next using Picard&rsquo;s <code>MarkDuplicates</code> tool we process output of <code>bwa mem</code>. This step produces two collections: (1) a collection of deduplicated BAMs and (2) a collection of duplicate metrics data produced by <code>MarkDuplicates</code> tool. We use <code>multiQC</code> to visualize the duplicate metrics. We then filter BAM collection produced by <code>MarkDuplicates</code> using <code>Filter SAM or BAM</code> tool to retain only properly mapped reads with mapping quality above 20 and mapping only to mitochondria (chrM). Finally output of the filtering step is merged with <code>MergeSAM</code> tool and displayed in the UCSC Genome Browser. Again, merging is only possible because we have set the readgroups during the mapping step.</small></td>
</tr>
</tbody>
</table>

<iframe src="https://player.vimeo.com/video/219916942?byline=0&portrait=0" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p><br></p>

<p>The merged BAM file can be using in a variety of downstream analyses. In this example we only used four samples represented by eight paired fastq datasets. Collection, prominently featured in this tutorial, make it easy to apply the same exact analysis logic to 100s or 1,000s of datasets.</p>

<h2 id="try-it-yourself-2">Try it yourself</h2>

<p>Perform a similar analyses with your own data.</p>

<h1 id="if-things-don-t-work">If things don&rsquo;t work&hellip;</h1>

<ul>
<li>&hellip;create an issue by clicking &ldquo;New issue&rdquo; button <a href="https://github.com/galaxyproject/galaxy/issues">here</a></li>
<li>&hellip;complain. Use <a href="https://usegalaxy.org/biostar/biostar_redirect">Galaxy&rsquo;s BioStar Channel</a> to do this.</li>
</ul>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://nekrut.github.io/BMMB554/posts/python1/"><i class="fa fa-chevron-circle-left"></i> Python: The very first try</a>
        </li>
        
        
    </ul>
</section>
    





</main>
    <footer>
        <h6>Anton Nekrutenko | 2018 | CC-BY </h6>
    </footer>
</div>
<script src="https://nekrut.github.io/BMMB554/js/scripts.js"></script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

</body>
</html>


